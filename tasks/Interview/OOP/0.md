### Как связаны классы и объекты?

> Классы – шаблоны (blueprint) конкретных объектов, т.е. на их основе создаются экземпляры, наследующие свойства и методы родителей.
> 
> ООП в языке Python базируется на следующей иерархии:
> 
> 1. Имеется головной класс object(), являющийся основой для всех других (обычно, его явно не указывают);
> 
> 2. Уровнем ниже расположены метаклассы , классы и подклассы (как самого Питона, так и пользовательские);
> 
> 3. В результате получаем возможность создавать любое количество экземпляров классов, т.е. объектов.
> 
> А вообще говоря - все в Питоне является объектом (даже класс). Это просто нужно запомнить.

### Для чего необходимо ключевое слово self в классах?

> Так как на основе классов создаются конкретные объекты, необходима возможность получения доступа к каждому из них. 
> 
> Ключевое слово self обозначает текущий объект класса. 
> 
> Это некая договоренность (так как self никто не запрещает заменить на любое другое слово).
> 
> Слово self применяется в следующий случаях:
> - В качестве первого аргумента у методов экземпляра класса;
> - Для доступа к свойству объекта внутри класса.

```python
class Hello:
    # self - указание на экземпляр класса
    def __init__(self, name):
        # Свойство объекта
        self.name = name
        print(f'Привет, {self.name}')

greet_me = Hello('Дмитрий')  # Привет, Дмитрий
```

### Как реализуется наследование классов в Python?
> Наследование – один из основных принципов ООП. 
> 
> Его суть выражается в следующем: на основании одних классов (базовых, суперклассов) можно создавать другие (подклассы), наследующие их свойства и методы.
> 
> Такой подход существенно снижает дублирование кода:
> 
> Нет нужды переписывать одни и те же методы и свойства у разных объектов;
> 
> Методы и свойства наследников не запрещено дополнять или модифицировать.
> 
> Как уже упоминалось выше, принцип наследования упрощает представление объектов как сущностей в реальном мире. 
> 
> Другими словами, человеческое сознание работает сходным образом: окружающие нас вещи мы легко может выстроить иерархически. 
> 
> Например, воробей относится к птицам, а птицы являются представителями животного царства. 
> 
> Аналогичным образом поступают и при создании классов: сначала определяют общий, а от него создаются частные, со своими особенностями.

```python
class Bird:

    def __init__(self, age, fly_distance):
        self.age = age
        self.fly_distance = fly_distance

    def fly(self):
        print(f"Птица может пролететь за раз километров: {self.fly_distance}")

    def human_age(self):
        print(f'Этой птице {self.age * 6} человеческих лет')


class Sparrow(Bird):

    def __init__(self, age, fly_distance, sound):
        super().__init__(age, fly_distance)
        self.sound = sound

    def human_age(self):
        print(f'Данному воробью {self.age * 25} человеческих лет')

    def sing(self):
        print(self.sound)


crow = Bird(11, 5)
crow.fly()
crow.human_age()
young_sparrow = Sparrow(1, 2, 'чик-чирик')
old_sparrow = Sparrow(3, 1, 'чирик-чирик')
young_sparrow.fly()
young_sparrow.sing()
young_sparrow.human_age()
old_sparrow.human_age()


# Результат выполнения
# ---
# Птица пролетела километров: 5
# Этой птице 66 человеческих лет
# Птица пролетела километров: 2
# чик-чирик
# Данному воробью 25 человеческих лет
# Данному воробью 75 человеческих лет
```

> Функция super() позволяет ссылаться на родительский суперкласс. 
> 
> Класс Sparrow унаследовал от Bird метод fly(), затем дополнительно мы ему создали собственный метод sound() и изменили метод предка human_age().


### Как создаются и для чего нужны статические методы?

> Метод экземпляра
> 
> Это очень простой и простой метод, который мы регулярно используем при создании классов на python. 
> 
> Если мы хотим напечатать переменную экземпляра или метод экземпляра, мы должны создать объект этого требуемого класса.
> 
> Если мы используем selfв качестве параметра функции или перед переменной, то это не что иное, как сам вызывающий экземпляр.
> 
> Поскольку мы работаем с переменными экземпляра, мы используем selfключевое слово.
> 
> Примечание: Переменные экземпляра используются с методами экземпляра.

```python
# Instance Method Example in Python 
class Student:
    
    def __init__(self, a, b):
        self.a = a
        self.b = b 
    
    def avg(self):
        return (self.a + self.b) / 2

s1 = Student(10, 20)
print( s1.avg() )

# Вывод:
# 15.0
```

> В приведенной выше программе aи bявляются переменными экземпляра, и они инициализируются, когда мы создаем объект для Studentкласса. 
> 
> Если мы хотим вызвать avg()функцию, которая является методом экземпляра, мы должны создать объект для класса.
> 
> Если мы четко посмотрим на программу, self ключевое слово используется так, что мы можем легко сказать, что это переменные и методы экземпляра.

> Метод класса
> 
> classsmethod() функция возвращает метод класса в качестве выходных данных для данной функции.
> 
> Вот синтаксис для него:
> 
> classmethod(function)
> 
> classmethod()Метод принимает только функцию в качестве входного параметра и преобразует ее в метод класса.
> 
> Существует два способа создания методов класса в python:
> 
> Использование метода класса (функции)
> 
> Использование аннотации @classmethod
> 
> Метод класса может быть вызван либо с использованием класса (например, C.f()), либо с использованием экземпляра (например, C().f()). 
> 
> Экземпляр игнорируется, за исключением его класса. 
> 
> Если метод класса вызывается из производного класса, объект производного класса передается в качестве подразумеваемого первого аргумента.
> 
> Поскольку мы работаем с ClassMethod, мы используем clsключевое слово. Переменные класса используются с методами класса.

```python
# Class Method Implementation in python 
class Student:
    name = 'Student'
    def __init__(self, a, b):
        self.a = a
        self.b = b 
    
    @classmethod
    def info(cls):
        return cls.name

print(Student.info())

# Вывод:
# Student
```

> В приведенном выше примере nameэто переменная класса. 
> 
> Если мы хотим создать метод класса, мы должны использовать @classmethodдекоратор и clsв качестве параметра для этой функции.

> Статический метод
> 
> Статический метод может быть вызван без объекта для этого класса, используя непосредственно имя класса. 
> 
> Если вы хотите сделать что-то дополнительное с классом, мы используем статические методы.
> 
> Например, если вы хотите напечатать факториал числа, то нам не нужно использовать переменные класса или переменные экземпляра для печати факториала числа. 
> 
> Мы просто передаем число созданному нами статическому методу, и он возвращает факториал.

```python
# Static Method Implementation in python
class Student:
    name = 'Student'
    def __init__(self, a, b):
        self.a = a
        self.b = b 
    
    @staticmethod
    def info():
        return "This is a student class"

print(Student.info())

# Вывод
# This a student class
```
