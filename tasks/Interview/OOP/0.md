### Как связаны классы и объекты?

> Классы – шаблоны (blueprint) конкретных объектов, т.е. на их основе создаются экземпляры, наследующие свойства и методы родителей.
> 
> ООП в языке Python базируется на следующей иерархии:
> 
> 1. Имеется головной класс object(), являющийся основой для всех других (обычно, его явно не указывают);
> 
> 2. Уровнем ниже расположены метаклассы , классы и подклассы (как самого Питона, так и пользовательские);
> 
> 3. В результате получаем возможность создавать любое количество экземпляров классов, т.е. объектов.
> 
> А вообще говоря - все в Питоне является объектом (даже класс). Это просто нужно запомнить.

### Для чего необходимо ключевое слово self в классах?

> Так как на основе классов создаются конкретные объекты, необходима возможность получения доступа к каждому из них. 
> 
> Ключевое слово self обозначает текущий объект класса. 
> 
> Это некая договоренность (так как self никто не запрещает заменить на любое другое слово).
> 
> Слово self применяется в следующий случаях:
> - В качестве первого аргумента у методов экземпляра класса;
> - Для доступа к свойству объекта внутри класса.

```python
class Hello:
    # self - указание на экземпляр класса
    def __init__(self, name):
        # Свойство объекта
        self.name = name
        print(f'Привет, {self.name}')

greet_me = Hello('Дмитрий')  # Привет, Дмитрий
```

### Как реализуется наследование классов в Python?
> Наследование – один из основных принципов ООП. 
> 
> Его суть выражается в следующем: на основании одних классов (базовых, суперклассов) можно создавать другие (подклассы), наследующие их свойства и методы.
> 
> Такой подход существенно снижает дублирование кода:
> 
> Нет нужды переписывать одни и те же методы и свойства у разных объектов;
> 
> Методы и свойства наследников не запрещено дополнять или модифицировать.
> 
> Как уже упоминалось выше, принцип наследования упрощает представление объектов как сущностей в реальном мире. 
> 
> Другими словами, человеческое сознание работает сходным образом: окружающие нас вещи мы легко может выстроить иерархически. 
> 
> Например, воробей относится к птицам, а птицы являются представителями животного царства. 
> 
> Аналогичным образом поступают и при создании классов: сначала определяют общий, а от него создаются частные, со своими особенностями.

```python
class Bird:

    def __init__(self, age, fly_distance):
        self.age = age
        self.fly_distance = fly_distance

    def fly(self):
        print(f"Птица может пролететь за раз километров: {self.fly_distance}")

    def human_age(self):
        print(f'Этой птице {self.age * 6} человеческих лет')


class Sparrow(Bird):

    def __init__(self, age, fly_distance, sound):
        super().__init__(age, fly_distance)
        self.sound = sound

    def human_age(self):
        print(f'Данному воробью {self.age * 25} человеческих лет')

    def sing(self):
        print(self.sound)


crow = Bird(11, 5)
crow.fly()
crow.human_age()
young_sparrow = Sparrow(1, 2, 'чик-чирик')
old_sparrow = Sparrow(3, 1, 'чирик-чирик')
young_sparrow.fly()
young_sparrow.sing()
young_sparrow.human_age()
old_sparrow.human_age()


# Результат выполнения
# ---
# Птица пролетела километров: 5
# Этой птице 66 человеческих лет
# Птица пролетела километров: 2
# чик-чирик
# Данному воробью 25 человеческих лет
# Данному воробью 75 человеческих лет
```

> Функция super() позволяет ссылаться на родительский суперкласс. 
> 
> Класс Sparrow унаследовал от Bird метод fly(), затем дополнительно мы ему создали собственный метод sound() и изменили метод предка human_age().
