### В чем разница между выражениями: True == 1 и True is 1? Какие результаты получим при их вычислении?
```python
# Когда мы пишем True == 1, то сравниваем значения. Так как класс bool является подклассом целых чисел, то True в данном случае будет той же самой единицей.
# Когда задается выражение True is 1, то сравниваются адреса в памяти. 
# Так как логические данные являются синглтон-объектами, то у них имеется собственный адрес в памяти, который не меняется по ходу работы скрипта. 
# Поэтому число 1 и True – занимают разные области в памяти.
print(True == 1)  # True 
print(True is 1)  # False 
print(id(True), (id(1))  # (2078150976, 2078275504)
```

### Почему следует избегать выражений типа «a and not b or not c and d or e»? Как его модифицировать для удобочитаемости?
> Компьютер способен выполнять и еще более сложные выражения. 
> А вот человеку, читающему такой код, будет очень сложно понять, каков порядок вычисления значений.
> Если при написании программы приходится использовать такую конструкцию, то ее нужно обернуть в скобки в порядке выполнения. 

> Это существенно упростит понимание выражения:
> ((a and not b) or (not c and d)) or e.
> 1 and not 2 or not 3 and 0 or 4 => 4
> ((1 and not 2) or (not 3 and 0)) or 4 => 4

### Какие объекты в Python всегда возвращают булево значение False?
```python
# Если применить функцию bool() к большинству объектов в Python, то получим True. Все возможные исключения представлены ниже:
print(bool(False))  # False
print(bool(None))  # False
print(bool(0))  # False
print(bool(''))  # False
print(bool([]))  # False
print(bool({}))  # False
```

### Определите приоритет выполнения операций при использовании булевых операторов.
> Булевы операции выполняются слева направо в таком приоритете:
> в первую очередь рассчитываются выражения с оператором not;
> далее вычисляют все конструкции, имеющие оператор and;
> в последнюю очередь работаем с or.

> Приведем пример вычисления выражения a or b and not c:
> 2 or 3 and not 1.
> Вначале узнаем результат операции not 1: False.
> Далее сравниваем 3 и False: 3 and False = False.
> Последний шаг: 2 or False = 2.

> 2 or 3 and not 1 => 2
