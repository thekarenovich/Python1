# -*- coding: UTF-8 -*-

'''
Центральный процессор
Процессор персонального компьютера представляет собой микросхему,
которая отвечает за выполнение любых операций с данными и управляет периферийными устройствами.
Он содержится в специальном кремниевом корпусе, называемом кристаллом.
Для краткого обозначения используют аббревиатуру — ЦП (центральный процессор) или
CPU (от англ. Central Processing Unit – центральное обрабатывающее устройство).
На современном рынке компьютерных комплектующих присутствуют две конкурирующие корпорации, Intel и AMD,
которые беспрестанно участвуют в гонке за производительность новых процессоров,
постоянно совершенствуя технологический процесс.
Ядро – самый главный элемент центрального процессора.
Оно представляет собой часть процессора, способное выполнять один поток команд.
Ядра отличаются по размеру кэш памяти, частоте шины, технологии изготовления и т. д.
Современное программное обеспечение проектируется так, что его функции и задачи могут выполняться параллельно. Python предоставляет программисту мощный набор инструментов для работы с потоками в библиотеке threading.
Как работает многопоточность
Многопоточность — это выполнение программы сразу в нескольких потоках, которые выполняют её функции одновременно.
Многопоточное программирование можно спутать с мультипроцессорным. На самом деле их концепции очень похожи,
но если в первом случае программа работает с потоками, то в другом — с процессами.
Разница между потоками и процессами проста: потоки имеют общую память, поэтому изменения в одном потоке видны в других,
а процессы используют разные области памяти.
Можно ли считать threading многопоточным?
В Python используется GIL (Global Interpreter Lock), который однопоточный.
Все потоки, которые создаются с помощью threading будут работать внутри потока GIL.
В связи с этим они будут обрабатываться только одним ядром.
Ни о какой работе одновременно на нескольких физических ядрах процессора не может быть и речи.
А так как threading будет выполняться только на одном ядре процессора, то нету преимущества по скорости,
только наоборот — threading замедлит работу.
Но без него никуда не деться, если вам нужно выполнять несколько задач одновременно:
Обрабатывать нажатие кнопки в графическом интерфейсе, например с помощью Tkinter.
Если по нажатию кнопки надо производить много действий, которые требуют времени,
то эти действия надо выполнять в другом потоке, чтобы графический интерфейс не подвис на это время.
Соответственно кнопки надо блокировать, а как поток завершит вычисления — обратно разблокировать.
Если наша программа работает одновременно с несколькими подключенными устройствами.
Они могут быть подключены к разным COM-портам.
Если мы загружаем файлы из сети и одновременно обрабатываем уже загруженные.
И так далее…
Если нам нужно, чтобы наша программа работала на нескольких физических ядрах процессора одновременно,
то следует обратить внимание на другой модуль — Multiprocessing.
________________________________________________________________________________________________________________________
threading.Thread()
Эта конструкция позволяет создать новый поток, создав экземпляр класса Thread. Вот как выглядят её аргументы:
Она принимает аргументы:
threading.Thread(group=None, target=None, name=None, args=(),
                 kwargs={}, *, daemon=None)
Рассмотрим их подробнее:
group. Имеет значение None, зарезервирована для будущего расширения при реализации класса ThreadGroup.
target. Это функция, которая выполняется в потоке с помощью метода run(), если передано значение None, ничего не
вызывается.
name. Это имя потока, по умолчанию оно принимает значение «Thread-X», где X – десятичное число. Программист может
задать имя вручную.
args. Это кортеж, в котором хранятся аргументы, передаваемые в вызываемую функцию.
kwargs. Это словарь, в котором хранятся аргументы, передаваемые в функцию.
daemon. Это параметр, который устанавливает, является ли поток демоническим. По умолчанию имеет значение None, тогда
свойство daemonic наследуется от текущего потока. Программист может самостоятельно установить значение параметра.

Демоны
Демонами называют процессы, которые работают в фоновом режиме.
В Python для демона есть более конкретное значение: демонический поток или поток демона.
В отличие от обычных потоков поток демона автоматически завершает свою работу при закрытии программы.
Иными словами, программа не будет ожидать завершения демонического потока, при её закрытии эти потоки уничтожаются,
в каком бы состоянии они не находились.


start()
Он используется для запуска созданного потока.
После использования threading.Thread() создаётся новый поток, однако он неактивен.
Для того чтобы он начал работу, используется метод start().

join()
Этот метод блокирует выполнение потока, который его вызвал, до тех пор пока не завершится поток,
метод которого был вызван. То есть если в потоке thread1 был вызван метод потока thread2: thread2.join(),
то поток thread1 будет приостановлен до тех пор, пока выполнение thread2 не завершится.
С помощью этого метода можно заставить программу дождаться завершения демонического потока.
Например, если вызвать метод в основном потоке, то программа не завершится, пока не выполнится демонический поток.
У метода join() есть аргумент timeout. По умолчанию он имеет значение None,
но программист может передать в него число с плавающей точкой. Если аргумент имеет значение по умолчанию,
то выполнение потока приостанавливается, пока выполняется поток метода. Если передать в качестве аргумента число,
то для метода join() установится время ожидания,
когда оно истечёт, поток продолжит свою работу.
Например, thr1.join(100) означает, что будет ожидаться завершение выполнения потока thr1 не более 100 секунд.

is_alive()
Метод проверяет выполняется ли поток в данный момент.
'''

import threading
import time


def myfunc(a, b):
    time.sleep(2.5)
    print('сумма :', a + b)
thr1 = threading.Thread(target=myfunc, args=(1, 2), daemon=True)
thr1.start()
thr1.join(0.125)
if thr1.is_alive():
    print('поток не успел завершиться')
else:
    print('вычисления завершены')  # при thr1.join()

# поток не успел завершиться
