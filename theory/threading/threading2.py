import threading
import time


'''
Состояние гонки
Состояние гонки или race condition – это ошибка, возникающая при неправильном проектировании многопоточной программы.
Она возникает тогда, когда несколько потоков обращаются к одним и тем же данным. Например, переменная хранит число,
которое пытаются одновременно изменить потоки thread1 и thread2, что приводит к непредсказуемым результатам или ошибке.
Распространена ситуация, когда один поток проверяет значение переменной на выполнение условия,
чтобы совершить какое-то действие, но между проверкой условия и выполнением действия вмешивается второй поток,
который изменяет значение переменной, что приводит к получению неправильных результатов, например:
x = 5
Thread 1:
if x == 5: # Поток 1 проверяет условие и считает его верным
Thread 2:
x = 1 # Поток два изменяет значение переменной
Thread 1:
print("При x = 5 функция 2*x =", 2 * x) # Поток один выполняет действие
В итоге программа выведет сообщение: «При x = 5 функция 2*x = 2».

Состояние гонки может приводить к различным проблемам:
- Утечки памяти.
- Потеря данных.
- Уязвимости в безопасности программы.
- Получение ошибочных результатов.
- Взаимные блокировки потоков.

Для того чтобы предотвратить состояние гонки, нужно использовать блокировку threading.Lock(), 
которая не позволяет сразу нескольким потокам работать с одними и теми же данными. 
Иными словами, Lock защищает данные от одновременного доступа.

acquire()
Метод позволяет потоку получить блокировку.

release()
Этот метод разблокирует объект Lock. Интерпретатор позволяет вызывать его из любого потока, 
а не только из потока, который заблокировал Lock в данный момент.
Метод ничего не возвращает и вызывает ошибку RuntimeError, если вызывается, когда объект Lock уже разблокирован.

Также следует помнить, что, хотя и можно вызывать acquire() несколько раз, 
метод release() нужно вызвать столько же раз. 
При каждом вызове acquire() уровень рекурсии увеличивается на единицу, 
соответственно при каждом вызове release() он уменьшается на единицу.
'''


# До использования Locker
'''
value = 0


def inc_value():
    global value
    while True:
        value += 1
        time.sleep(1)
        print(value)

for _ in range(5):
    thr = threading.Thread(target=inc_value, name='Thread').start()
'''


# Использование Locker
value = 0
locker = threading.Lock()


def inc_value():
    global value
    while True:
        locker.acquire()
        value += 1
        time.sleep(0.1)
        print(value)
        locker.release()

for _ in range(5):
    thr = threading.Thread(target=inc_value, name='Thread').start()
