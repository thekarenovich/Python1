Python - динамически типизированный, то есть не нужно переменным приписываться типы данных при объявлении. 
Работа с памятью в Python автомотизирована, то есть не нужно заранее выделять память, вручную освобождать ее. 
Python удаляет те объекты, которые больше не используются, можно сказать, что освобождает пространство памяти. 
Этот процесс удаления ненужного пространства памяти объекта называется сборщиком мусора. 
Сборщик мусора Python запускает свое выполнение вместе с программой и активируется, если счетчик ссылок падает до нуля.

Как мы знаем, в Python все является объектом. 
Объект может быть простым(содержащий числа, строки и т. д.) 
или контейнером(словарь, списки или определенные пользователем классы). 
В Python нам не нужно объявлять переменные или их типы перед их использованием в программе.

Подсчет ссылок показывает, сколько раз другие объекты ссылаются на данный объект. 
Когда назначается ссылка на объект, счетчик объектов увеличивается на единицу. 
Когда ссылки на объект удаляются, количество объектов уменьшается. 
Когда счетчик ссылок становится равным нулю, диспетчер памяти Python выполняет освобождение.

```python
x = 20
y = x
if id(x) == id(y):
   print("The variables x and y are referring to the same object")
```   

Когда мы присваиваем значение переменной x, целочисленный объект 20 создается в памяти кучи, и его ссылка присваивается x. 
В приведенном выше коде мы присвоили y = x, что означает, что объект y будет ссылаться на тот же объект,
потому что Python выделил ту же ссылку на объект новой переменной, если объект уже существует с тем же значением.

```python
x = 20
y = x
x += 1
if id(x) == id(y):
   print("x and y do not refer to the same object")
```

Переменные x и y не ссылаются на один и тот же объект, потому что x увеличивается на единицу, x создает новый объект ссылки, а y по-прежнему ссылается на 20.

________

Также стоит отметить, что важно понимать различие между изменяемыми и неизменяемыми типами данных, 
поскольку если выше мы могли работать с числом, хоть со строкой, и при изменении хотя бы одного из переменных обе были уже отличны друг от друга, 
ибо оба отсылаются на разные объекты, то с изменяемыми иначе: если переменна а равняется, скажем списку, а затем переменной b присвоить а, 
то они будут отсылаться на один тот же список, тут все понятно. Но если изменить значение а, то значение b также изменится.
